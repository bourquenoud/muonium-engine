/*
 * Matrix4.cpp
 *
 *  Created on: 6 Apr 2021
 *      Author: mathieu
 */

#include "Matrix4.hpp"

namespace ue
{
  Matrix4 Matrix4::operator-()
  {
    Matrix4 C;

    C.d[0][0] = -d[0][0];
    C.d[0][1] = -d[0][1];
    C.d[0][2] = -d[0][2];
    C.d[0][3] = -d[0][3];

    C.d[1][0] = -d[1][0];
    C.d[1][1] = -d[1][1];
    C.d[1][2] = -d[1][2];
    C.d[1][3] = -d[1][3];

    C.d[2][0] = -d[2][0];
    C.d[2][1] = -d[2][1];
    C.d[2][2] = -d[2][2];
    C.d[2][3] = -d[2][3];

    C.d[3][0] = -d[3][0];
    C.d[3][1] = -d[3][1];
    C.d[3][2] = -d[3][2];
    C.d[3][3] = -d[3][3];

    return C;
  }
  Matrix4 Matrix4::operator+(Matrix4& B)
  {
    Matrix4 C;

    C.d[0][0] = d[0][0] + B.d[0][0];
    C.d[0][1] = d[0][1] + B.d[0][1];
    C.d[0][2] = d[0][2] + B.d[0][2];
    C.d[0][3] = d[0][3] + B.d[0][3];

    C.d[1][0] = d[1][0] + B.d[1][0];
    C.d[1][1] = d[1][1] + B.d[1][1];
    C.d[1][2] = d[1][2] + B.d[1][2];
    C.d[1][3] = d[1][3] + B.d[1][3];

    C.d[2][0] = d[2][0] + B.d[2][0];
    C.d[2][1] = d[2][1] + B.d[2][1];
    C.d[2][2] = d[2][2] + B.d[2][2];
    C.d[2][3] = d[2][3] + B.d[2][3];

    C.d[3][0] = d[3][0] + B.d[3][0];
    C.d[3][1] = d[3][1] + B.d[3][1];
    C.d[3][2] = d[3][2] + B.d[3][2];
    C.d[3][3] = d[3][3] + B.d[3][3];

    return C;
  }
  Matrix4 Matrix4::operator-(Matrix4& B)
  {
    Matrix4 C;

    C.d[0][0] = d[0][0] - B.d[0][0];
    C.d[0][1] = d[0][1] - B.d[0][1];
    C.d[0][2] = d[0][2] - B.d[0][2];
    C.d[0][3] = d[0][3] - B.d[0][3];

    C.d[1][0] = d[1][0] - B.d[1][0];
    C.d[1][1] = d[1][1] - B.d[1][1];
    C.d[1][2] = d[1][2] - B.d[1][2];
    C.d[1][3] = d[1][3] - B.d[1][3];

    C.d[2][0] = d[2][0] - B.d[2][0];
    C.d[2][1] = d[2][1] - B.d[2][1];
    C.d[2][2] = d[2][2] - B.d[2][2];
    C.d[2][3] = d[2][3] - B.d[2][3];

    C.d[3][0] = d[3][0] - B.d[3][0];
    C.d[3][1] = d[3][1] - B.d[3][1];
    C.d[3][2] = d[3][2] - B.d[3][2];
    C.d[3][3] = d[3][3] - B.d[3][3];

    return C;
  }
  /*
   * Calculate the product of matrix 4x4 A and B
   */
  Matrix4 Matrix4::operator*(Matrix4& B)
  {
    Matrix4 C;

    //Unfolded, faster

    C.d[0][0] = d[0][0]*B.d[0][0] + d[0][1]*B.d[1][0] + d[0][2]*B.d[2][0] + d[0][3]*B.d[3][0];
    C.d[0][1] = d[0][0]*B.d[0][1] + d[0][1]*B.d[1][1] + d[0][2]*B.d[2][1] + d[0][3]*B.d[3][1];
    C.d[0][2] = d[0][0]*B.d[0][2] + d[0][1]*B.d[1][2] + d[0][2]*B.d[2][2] + d[0][3]*B.d[3][2];
    C.d[0][3] = d[0][0]*B.d[0][3] + d[0][1]*B.d[1][3] + d[0][2]*B.d[2][3] + d[0][3]*B.d[3][3];

    C.d[1][0] = d[1][0]*B.d[0][0] + d[1][1]*B.d[1][0] + d[1][2]*B.d[2][0] + d[1][3]*B.d[3][0];
    C.d[1][1] = d[1][0]*B.d[0][1] + d[1][1]*B.d[1][1] + d[1][2]*B.d[2][1] + d[1][3]*B.d[3][1];
    C.d[1][2] = d[1][0]*B.d[0][2] + d[1][1]*B.d[1][2] + d[1][2]*B.d[2][2] + d[1][3]*B.d[3][2];
    C.d[1][3] = d[1][0]*B.d[0][3] + d[1][1]*B.d[1][3] + d[1][2]*B.d[2][3] + d[1][3]*B.d[3][3];

    C.d[2][0] = d[2][0]*B.d[0][0] + d[2][1]*B.d[1][0] + d[2][2]*B.d[2][0] + d[2][3]*B.d[3][0];
    C.d[2][1] = d[2][0]*B.d[0][1] + d[2][1]*B.d[1][1] + d[2][2]*B.d[2][1] + d[2][3]*B.d[3][1];
    C.d[2][2] = d[2][0]*B.d[0][2] + d[2][1]*B.d[1][2] + d[2][2]*B.d[2][2] + d[2][3]*B.d[3][2];
    C.d[2][3] = d[2][0]*B.d[0][3] + d[2][1]*B.d[1][3] + d[2][2]*B.d[2][3] + d[2][3]*B.d[3][3];

    C.d[3][0] = d[3][0]*B.d[0][0] + d[3][1]*B.d[1][0] + d[3][2]*B.d[2][0] + d[3][3]*B.d[3][0];
    C.d[3][1] = d[3][0]*B.d[0][1] + d[3][1]*B.d[1][1] + d[3][2]*B.d[2][1] + d[3][3]*B.d[3][1];
    C.d[3][2] = d[3][0]*B.d[0][2] + d[3][1]*B.d[1][2] + d[3][2]*B.d[2][2] + d[3][3]*B.d[3][2];
    C.d[3][3] = d[3][0]*B.d[0][3] + d[3][1]*B.d[1][3] + d[3][2]*B.d[2][3] + d[3][3]*B.d[3][3];

    return C;
  }

  Vector4 Matrix4::operator*(Vector4& v)
  {
    Vector4 u;

    u.x = v.x * d[0][0] + v.y * d[0][1] + v.z * d[0][2] + v.w * d[0][3];
    u.y = v.x * d[1][0] + v.y * d[1][1] + v.z * d[1][2] + v.w * d[1][3];
    u.z = v.x * d[2][0] + v.y * d[2][1] + v.z * d[2][2] + v.w * d[2][3];
    u.w = v.x * d[3][0] + v.y * d[3][1] + v.z * d[3][2] + v.w * d[3][3];

    return u;
  }

  Vector3 Matrix4::operator*(Vector3& v)
  {
    Vector3 u;

    u.x = v.x * d[0][0] + v.y * d[0][1] + v.z * d[0][2] + d[0][3];
    u.y = v.x * d[1][0] + v.y * d[1][1] + v.z * d[1][2] + d[1][3];
    u.z = v.x * d[2][0] + v.y * d[2][1] + v.z * d[2][2] + d[2][3];

    return u;
  }

  Real* Matrix4::operator[](int i)
  {
    return d[i];
  }
}

